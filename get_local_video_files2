import cv2
import ultralytics import YOLO
import tensorflow as tf
import pandas as pd
import matplotlib as plt
import numpy as np

#1. ë¡œì»¬ ë‚´ ì˜ìƒ íŒŒì¼ ê°€ì ¸ì˜¤ê¸°

def get_local_video_files(num_files=1):
    """ë¡œì»¬ ë¹„ë””ì˜¤ íŒŒì¼ ì„ íƒ (1ê°œ ë˜ëŠ” 2ê°œ)"""
    print(f"ğŸ¬ ë¡œì»¬ ë¹„ë””ì˜¤ íŒŒì¼ {num_files}ê°œë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”")
    print("ì§€ì› í˜•ì‹: .mp4, .avi, .mov, .mkv, .wmv, .flv, .webm")

    video_files = []
    for i in range(num_files):
        print(f"\nğŸ“ {i + 1}ë²ˆì§¸ ë¹„ë””ì˜¤ íŒŒì¼:")
        while True:
            video_path = input(f"ë¹„ë””ì˜¤ íŒŒì¼ {i + 1} ê²½ë¡œ: ").strip().strip('"').strip("'")
            if not video_path:
                print("ê²½ë¡œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!")
                continue
            if not os.path.exists(video_path):
                print(f"âŒ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {video_path}")
                continue
            if not any(video_path.lower().endswith(ext) for ext in ['.mp4', '.avi', '.mov', '.mkv', '.wmv', '.flv', '.webm']):
                print("âŒ ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.")
                continue
            test_cap = cv2.VideoCapture(video_path)
            if not test_cap.isOpened():
                print("âŒ ë¹„ë””ì˜¤ íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                continue
            fps = test_cap.get(cv2.CAP_PROP_FPS)
            frame_count = int(test_cap.get(cv2.CAP_PROP_FRAME_COUNT))
            width = int(test_cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            height = int(test_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            duration = frame_count / fps if fps > 0 else 0
            print(f"âœ… ë¹„ë””ì˜¤ {i + 1} ì •ë³´:")
            print(f"   íŒŒì¼ëª…: {os.path.basename(video_path)}")
            print(f"   í•´ìƒë„: {width}x{height}")
            print(f"   FPS: {fps:.1f}")
            print(f"   ê¸¸ì´: {duration:.1f}ì´ˆ")
            test_cap.release()
            video_files.append(video_path)
            break
    return video_files

# 1. ê°ì •ë¶„ì„ ëª¨ë¸ í´ë˜ìŠ¤ ì„¤ì •

class EmotionalAnalyzer:
    def __init__(self, model_path = None):

        self.emotions = ['angry', 'disgust', 'fear', 'happy', 'neutral', 'sad',
                         'surprise']
        self.emotion_colors = {
            'angry': (0, 0, 255), #ë¹¨ê°„ìƒ‰
            'disgust': (0, 255, 0),
            'fear': (255, 0, 255),
            'happy': (0, 255, 255),
            'neutral': (128 ,128, 128), #íšŒìƒ‰
            'sad': (255, 0, 0),
            'surprise': (0, 165, 255)
        }

        # ì™¸ë¶€ëª¨ë¸ / ì •ì˜í•œ ëª¨ë¸ ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¥¸ ì½”ë“œ
        if model_path and os.path.exists(model_path):
            self.model = load_model(model_path)
        else:
            self.model = self.create_default_model()

    def create_default_model(self):
        model = tf.keras.Sequential([
            tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(48, 48, 1)),
            tf.keras.layers.BatchNormalization(), #ë°°ì¹˜ ì •ê·œí™”: í•™ìŠµì„ ë¹ ë¥´ê²Œ í•˜ê³  ì•ˆì •ë˜ê²Œ í•˜ëŠ” ê¸°ëŠ¥.
            tf.keras.layers.Conv2D(64, (3, 3), activation='relu'), #featureì„ ë” ê¹Šê²Œ ì¶”ì¶œ
            tf.keras.layers.BatchNormalization(),
            tf.keras.layers.MaxPooling2D(2, 2), #2x2 í¬ê¸°ì˜ max pooling > íŠ¹ì„± ë§µì˜ í¬ê¸°ë¥¼ ì ˆë°˜ìœ¼ë¡œ ì¤„ì„
            tf.keras.layers.Dropout(0, 25), #ê³¼ì í•© ë°©ì§€

            tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),
            tf.keras.layers.BatchNormalization(),  # ë°°ì¹˜ ì •ê·œí™”: í•™ìŠµì„ ë¹ ë¥´ê²Œ í•˜ê³  ì•ˆì •ë˜ê²Œ í•˜ëŠ” ê¸°ëŠ¥.
            tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),  # featureì„ ë” ê¹Šê²Œ ì¶”ì¶œ
            tf.keras.layers.BatchNormalization(),
            tf.keras.layers.MaxPooling2D(2, 2),  # 2x2 í¬ê¸°ì˜ max pooling > íŠ¹ì„± ë§µì˜ í¬ê¸°ë¥¼ ì ˆë°˜ìœ¼ë¡œ ì¤„ì„
            tf.keras.layers.Dropout(0, 25),  # ê³¼ì í•© ë°©ì§€

            tf.keras.layers.Flatten(), #ìœ„ì—ì„œ ì¶”ì¶œëœ ë‹¤ì°¨ì› ë²¡í„°ë¥¼ 1ì°¨ì› ë²¡í„°ë¡œ ë³€í™˜.
            tf.keras.layers.Dense(512, activation = 'relu'), #512ê°œì˜ ë‰´ëŸ°ì„ ê°€ì§„ Fully Connected Layer ì‚¬ìš©
            #ì…ë ¥ê°’ * ê°€ì¤‘ì¹˜ + í¸í–¥ -> í™œì„±í™”í•¨ìˆ˜ -> ì¶œë ¥ê°’ :: ì´ ê³¼ì •ì„ 512ë²ˆ í‰í–‰í•˜ê²Œ ì‹¤í–‰.
            #í•©ì„±ê³±(Flattenì´ì „ì˜ ì¸µë“¤)ì€ êµ­ì†Œì ì¸ íŠ¹ì§•ì„ ë½‘ëŠ”ë° ê°•ì . ë”°ë¼ì„œ ì „ì²´ì´ë¯¸ì§€ë¥¼ ë³´ê³  íŒë‹¨í•˜ê¸° ìœ„í•´ ì™„ì „ì—°ê²°ì¸µì´ í•„ìš”.
            tf.keras.layers.BatchNormalization(),
            tf.keras.layers.Dropout(0, 5),
            tf.keras.layers.Dense(7, activation = 'softmax')
        ])

        model.compile(
            optimizer = 'adam', #ë”¥ëŸ¬ë‹ ëª¨ë¸ í•™ìŠµ ê³¼ì •ì—ì„œ ì†ì‹¤ í•¨ìˆ˜ì˜ ê²°ê³¼ê°’ì„ ìµœì†Œí™”í•˜ëŠ” íŒŒë¼ë¯¸í„°ë¥¼ ì°¾ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ì•Œê³ ë¦¬ì¦˜
            loss = 'categorical_crossentropy', #ì†ì‹¤í•¨ìˆ˜: ëª¨ë¸ì˜ ì˜ˆì¸¡ê°’ê³¼ ì‹¤ì œê°’ ì‚¬ì´ì˜ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ì—¬ ëª¨ë¸ì˜ ì„±ëŠ¥ì„ í‰ê°€
            metrics = ['accuracy']
        )

        return model


    #ì–¼êµ´ì´ë¯¸ì§€ì²˜ë¦¬ í•¨ìˆ˜ ë§Œë“¤ê¸°
    def preprocess_face(self, face_img):
        #ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
        if len(face_img.shape) == 3:
            face_imag = cv2.cvtColor(face_img, cv2.COLOR_BAYER_RG2GRAY)

        #í¬ê¸° ì¡°ì •
        face_img = cv2.resize(face_img, (48, 48))

        #ì •ê·œí™” >> ì•ˆì •ì„± í–¥ìƒì„ ìœ„í•´ ìƒˆìš©
        face_img = face_img.astype('float32') / 255.0

        #ì°¨ì› í™•ì¥ >> í˜„ì¬ê¹Œì§€ ì´ë¯¸ì§€ë¥¼ í‘ë°±ìœ¼ë¡œ í•´ì„œ shapeì´ (48, 48)ì„.
        #CNNëª¨ë¸(ìš°ë¦¬ê°€ ì´ë¯¸ì§€ë¥¼ ë„£ì„..)ì€ (height, width, channels) í˜•íƒœê°€ ë“¤ì–´ê°€ì•¼í•¨. ë”°ë¼ì„œ (48, 48, 1)ì˜ í˜•íƒœë¡œ ë§Œë“¤ì–´ì¤Œ.
        face_img = np.expand_dims(face_img, axis = -1)
        face_img = np.expand_dims(face_img, axis = 0)

        return face_img


    #ê°ì • ì˜ˆì¸¡ í•¨ìˆ˜
    def predict_emotion(self, face_img):
        try:
            #ì „ì²˜ë¦¬
            processed_face = self.preprocess_face(face_img)

            #ì˜ˆì¸¡
            predictions = self.model.predict(processed_face, verbose=0)[0]

            #ê²°ê³¼ ì •ë¦¬
            emotion_probabilities = {
                emotion: float(prob) for emotion, prob in zip(self.emotions, predictions)}

            #ê°€ì¥ ë†’ì€ í™•ë¥ ì˜ ê°ì • ë°˜í™˜
            dominant_emotion = max(emotion_probabilities, key= emotion_probabilities.get)
            confidence = emotion_probabilities[dominant_emotion]

            return dominant_emotion, confidence, emotion_probabilities

        except Exception as e:
            return 'neutral', 0.0











